"""Factories for generating test data.

These factories are used to generate test data for the tests. They are
used both for generating in memory objects and for generating objects
that are persisted to the database.

The factories are based on the `factory_boy` library. See
https://factoryboy.readthedocs.io/en/latest/ for more information.
"""

import random
from datetime import datetime
from typing import Optional

import factory
import factory.fuzzy
import faker
from faker.providers import BaseProvider
from sqlalchemy import func
from sqlalchemy.orm import scoped_session

import src.adapters.db as db
import src.db.models.opportunity_models as opportunity_models
import src.db.models.staging as staging
import src.db.models.transfer.topportunity_models as transfer_topportunity_models
import src.util.datetime_util as datetime_util
from src.constants.lookup_constants import (
    AgencyDownloadFileType,
    AgencySubmissionNotificationSetting,
    ApplicantType,
    FundingCategory,
    FundingInstrument,
    OpportunityCategory,
    OpportunityCategoryLegacy,
    OpportunityStatus,
)
from src.db.models import agency_models


def sometimes_none(factory_value, none_chance: float = 0.5):
    return factory.Maybe(
        decider=factory.LazyAttribute(lambda s: random.random() > none_chance),
        yes_declaration=factory_value,
        no_declaration=None,
    )


class CustomProvider(BaseProvider):
    """
    This class is a custom faker provider that can be used to generate
    fake data for our specific scenarios.

    The name of the functions defined in this class is the name of the individual provider.
    For example, the "agency" method below can be called by doing either of the following::

        fake.agency()

        factory.Faker("agency")

    Below we register this provider class with both the faker instance we setup, as well as
    the underlying one backing the factory's faker instance.

    See: https://faker.readthedocs.io/en/master/#how-to-create-a-provider
    """

    # Ideally use agencies here that actually exist so anyone
    # using data generated by this for front-end dev actually
    # has valid values
    AGENCIES = ["USAID", "ARPAH", "DOC", "DOC-EDA"]

    # Various words we can use when building the agency names
    # Stuff that sounds like it might be an agency, even if its not exactly the name
    AGENCY_WORDS = [
        "Agriculture",
        "Commerce",
        "Defense",
        "Education",
        "Economics",
        "Energy",
        "Health",
        "Housing",
        "Justice",
        "Labor",
        "State",
        "Interior",
        "Transportation",
        "Science",
        "Arts",
    ]

    AGENCY_NAME_FORMATS = [
        "Department of {{agency_word}}",
        "Department of the {{agency_word}}",
        "Agency for {{agency_word}}",
        "National {{agency_word}} Administration",
    ]

    AGENCY_CONTACT_DESC_FORMATS = [
        "{{name}}\n{{job}}\n555-###-####\n{{email}}",
        "{{relevant_url}} Contact Center\nHours of operation are 24 hours a day, 7 days a week.\n{{email}}",
        "Webmaster\n{{email}}",
    ]

    # Rather than generate any random URL in our data, use those
    # that are vaguely relevant to avoid linking to anything outside
    # of the grants ecosystem that could cause confusion in test data
    # (ie. either a website we work with, or a very generic one)
    RELEVANT_URLS = ["google.com", "grants.gov", "simpler.grants.gov", "sam.gov"]

    ADDITIONAL_INFO_DESC_FORMATS = [
        "Full Announcement",
        "Grants.gov",
        "Link to grant on {{relevant_url}}",
        "Program Announcement",
        "Click on the link to see the full announcement.",
        "Division of {{company}}",
    ]

    # Opportunity title uses several other existing providers
    # to generate titles. Anything in {{ }} is calling a provider
    # with that name.
    OPPORTUNITY_TITLE_FORMATS = [
        "Research into {{job}} industry",
        "Embassy program for {{job}} in {{country}}",
        "{{name}} Foundation Grant for {{bs}}",
        "{{company}} {{year}} award",
    ]

    SUMMARY_DESCRIPTION_FORMATS = [
        "{{agency}} is looking to further investigate this topic. {{paragraph}}",
        "<p>{{paragraph}}</p><p><br></p><p>{{paragraph}}</p>",
        "The purpose of this Notice of Funding Opportunity (NOFO) is to support research into {{job}} and how we might {{catch_phrase}}.",
    ]

    # In the formatting, ? becomes a random letter, # becomes a random digit
    OPPORTUNITY_NUMBER_FORMATS = [
        "???-###-FY{{year}}-###",
        "{{agency}}-##-###",
        "???#######",
        "??-##-???-###",
        "{{word}}-###-##",
    ]

    YN_BOOLEAN_VALUES = ["Y", "N"]

    YN_YESNO_BOOLEAN_VALUES = ["Y", "N", "Yes", "No"]

    def agency(self) -> str:
        return self.random_element(self.AGENCIES)

    def agency_word(self) -> str:
        return self.random_element(self.AGENCY_WORDS)

    def agency_name(self) -> str:
        pattern = self.random_element(self.AGENCY_NAME_FORMATS)
        return self.generator.parse(pattern)

    def agency_contact_description(self) -> str:
        # bothify turns any ? into letters, and # into digits
        pattern = self.bothify(self.random_element(self.AGENCY_CONTACT_DESC_FORMATS))
        return self.generator.parse(pattern)

    def relevant_url(self):
        return self.random_element(self.RELEVANT_URLS)

    def additional_info_desc(self):
        pattern = self.random_element(self.ADDITIONAL_INFO_DESC_FORMATS)
        return self.generator.parse(pattern)

    def opportunity_number(self) -> str:
        # bothify turns any ? into letters, and # into digits
        pattern = self.bothify(self.random_element(self.OPPORTUNITY_NUMBER_FORMATS))
        return self.generator.parse(pattern).upper()

    def opportunity_title(self) -> str:
        pattern = self.random_element(self.OPPORTUNITY_TITLE_FORMATS)
        return self.generator.parse(pattern)

    def summary_description(self) -> str:
        pattern = self.random_element(self.SUMMARY_DESCRIPTION_FORMATS)
        return self.generator.parse(pattern)

    def yn_boolean(self) -> str:
        return self.random_element(self.YN_BOOLEAN_VALUES)

    def yn_yesno_boolean(self) -> str:
        return self.random_element(self.YN_YESNO_BOOLEAN_VALUES)


fake = faker.Faker()
fake.add_provider(CustomProvider)
factory.Faker.add_provider(CustomProvider)

_db_session: Optional[db.Session] = None


def get_db_session() -> db.Session:
    # _db_session is only set in the pytest fixture `enable_factory_create`
    # so that tests do not unintentionally write to the database.
    if _db_session is None:
        raise Exception(
            """Factory db_session is not initialized.

            If your tests don't need to cover database behavior, consider
            calling the `build()` method instead of `create()` on the factory to
            not persist the generated model.

            If running tests that actually need data in the DB, pull in the
            `enable_factory_create` fixture to initialize the db_session.
            """
        )

    return _db_session


# The scopefunc ensures that the session gets cleaned up after each test
# it implicitly calls `remove()` on the session.
# see https://docs.sqlalchemy.org/en/20/orm/contextual.html
Session = scoped_session(lambda: get_db_session(), scopefunc=lambda: get_db_session())


class Generators:
    Now = factory.LazyFunction(datetime.now)
    UtcNow = factory.LazyFunction(datetime_util.utcnow)
    UuidObj = factory.Faker("uuid4", cast_to=None)
    PhoneNumber = factory.Sequence(lambda n: f"123-456-{n:04}")


class BaseFactory(factory.alchemy.SQLAlchemyModelFactory):
    class Meta:
        abstract = True
        sqlalchemy_session = Session
        sqlalchemy_session_persistence = "commit"


class OpportunityFactory(BaseFactory):
    class Meta:
        model = opportunity_models.Opportunity

    @classmethod
    def _setup_next_sequence(cls):
        if _db_session is not None:
            value = _db_session.query(
                func.max(opportunity_models.Opportunity.opportunity_id)
            ).scalar()
            if value is not None:
                return value + 1

        return 1

    opportunity_id = factory.Sequence(lambda n: n)

    opportunity_number = factory.Faker("opportunity_number")
    opportunity_title = factory.Faker("opportunity_title")

    agency = factory.Faker("agency")

    category = factory.fuzzy.FuzzyChoice(OpportunityCategory)
    # only set the category explanation if category is Other
    category_explanation = factory.Maybe(
        decider=factory.LazyAttribute(lambda o: o.category == OpportunityCategory.OTHER),
        yes_declaration=factory.Faker("sentence", nb_words=3),
        no_declaration=None,
    )

    is_draft = False  # Because we filter out drafts, just default these to False

    revision_number = 0  # We'll want to consider how we handle this when we add history

    opportunity_assistance_listings = factory.RelatedFactoryList(
        "tests.src.db.models.factories.OpportunityAssistanceListingFactory",
        factory_related_name="opportunity",
        size=lambda: random.randint(1, 3),
    )

    # By default we'll add a current opportunity summary which will be POSTED
    # if you'd like to easily modify the values, see the possible traits below in the
    # Params class section
    current_opportunity_summary = factory.RelatedFactory(
        "tests.src.db.models.factories.CurrentOpportunitySummaryFactory",
        factory_related_name="opportunity",
    )

    class Params:
        # These are common scenarios we might want for an opportunity.
        # Simply pass the in `trait_name=True` to the factory when making an object
        # and all of these will be set for you on the relevant models
        # See: https://factoryboy.readthedocs.io/en/stable/reference.html#traits

        no_current_summary = factory.Trait(current_opportunity_summary=None)

        # We set a trait for the OpportunitySummaryFactory for each of these as well as set the opportunity status
        is_posted_summary = factory.Trait(current_opportunity_summary__is_posted_summary=True)
        is_forecasted_summary = factory.Trait(
            current_opportunity_summary__is_forecasted_summary=True
        )
        is_closed_summary = factory.Trait(current_opportunity_summary__is_closed_summary=True)
        is_archived_non_forecast_summary = factory.Trait(
            current_opportunity_summary__is_archived_non_forecast_summary=True
        )
        is_archived_forecast_summary = factory.Trait(
            current_opportunity_summary__is_archived_forecast_summary=True
        )

        # Set all nullable fields to null
        all_fields_null = factory.Trait(
            agency=None,
            category=None,
            category_explanation=None,
            current_opportunity_summary=None,
            opportunity_assistance_listings=None,
        )

        # Set the timestamps in the past rather than using the default of "now"
        timestamps_in_past = factory.Trait(
            created_at=factory.Faker("date_time_between", start_date="-5y", end_date="-3y"),
            updated_at=factory.Faker("date_time_between", start_date="-3y", end_date="-1y"),
        )


class OpportunitySummaryFactory(BaseFactory):
    class Meta:
        model = opportunity_models.OpportunitySummary

    opportunity = factory.SubFactory(OpportunityFactory, current_opportunity_summary=None)
    opportunity_id = factory.LazyAttribute(lambda s: s.opportunity.opportunity_id)

    summary_description = factory.Faker("summary_description")
    is_cost_sharing = factory.Faker("boolean")

    # By default generate non-forecasts which affects several fields
    is_forecast = False

    # Forecasted records don't have a close date
    close_date = factory.Maybe(
        decider=factory.LazyAttribute(lambda s: s.is_forecast),
        # If forecasted, don't set a close date
        yes_declaration=None,
        # otherwise a future date
        no_declaration=factory.Faker("date_between", start_date="+2w", end_date="+3w"),
    )
    close_date_description = factory.Maybe(
        decider=factory.LazyAttribute(lambda s: s.close_date is None),
        yes_declaration=None,
        no_declaration=factory.Faker("paragraph", nb_sentences=1),
    )

    # Just a random recent post date
    post_date = factory.Faker("date_between", start_date="-3w", end_date="-1d")

    # By default set to a date in the future
    archive_date = factory.Faker("date_between", start_date="+3w", end_date="+4w")

    unarchive_date = None

    expected_number_of_awards = factory.Faker("random_int", min=1, max=25)
    estimated_total_program_funding = factory.Faker(
        "random_int", min=10_000, max=10_000_000, step=5_000
    )
    award_floor = factory.LazyAttribute(
        lambda s: s.estimated_total_program_funding // s.expected_number_of_awards
    )
    award_ceiling = factory.LazyAttribute(lambda s: s.estimated_total_program_funding)

    additional_info_url = factory.Faker("relevant_url")
    additional_info_url_description = factory.Faker("additional_info_desc")

    funding_category_description = factory.Maybe(
        decider=factory.LazyAttribute(lambda s: fake.boolean()),  # random chance to include value
        yes_declaration=factory.Faker("paragraph", nb_sentences=1),
        no_declaration=None,
    )
    applicant_eligibility_description = factory.Maybe(
        decider=factory.LazyAttribute(lambda s: fake.boolean()),  # random chance to include value
        yes_declaration=factory.Faker("paragraph", nb_sentences=5),
        no_declaration=None,
    )

    agency_code = factory.LazyAttribute(lambda s: s.opportunity.agency)
    agency_name = factory.Faker("agency_name")
    agency_phone_number = Generators.PhoneNumber
    agency_contact_description = factory.Faker("agency_contact_description")
    agency_email_address = factory.Faker("email")
    agency_email_address_description = factory.LazyAttribute(
        lambda s: f"Contact {s.agency_name} via email"
    )

    # Forecasted values are only set if is_forecast=True
    forecasted_post_date = factory.Maybe(
        decider=factory.LazyAttribute(lambda s: s.is_forecast),
        # If forecasted, set it in the future
        yes_declaration=factory.Faker("date_between", start_date="+2w", end_date="+3w"),
        # otherwise don't set
        no_declaration=None,
    )
    forecasted_close_date = factory.Maybe(
        decider=factory.LazyAttribute(lambda s: s.is_forecast),
        # If forecasted, set it in the future
        yes_declaration=factory.Faker("date_between", start_date="+6w", end_date="+12w"),
        # otherwise don't set
        no_declaration=None,
    )
    forecasted_close_date_description = factory.Maybe(
        decider=factory.LazyAttribute(lambda s: s.forecasted_close_date is None),
        yes_declaration=None,
        no_declaration=factory.Faker("paragraph", nb_sentences=1),
    )
    forecasted_award_date = factory.Maybe(
        decider=factory.LazyAttribute(lambda s: s.is_forecast),
        # If forecasted, set it in the future
        yes_declaration=factory.Faker("date_between", start_date="+26w", end_date="+30w"),
        # otherwise don't set
        no_declaration=None,
    )
    forecasted_project_start_date = factory.Maybe(
        decider=factory.LazyAttribute(lambda s: s.is_forecast),
        # If forecasted, set it in the future
        yes_declaration=factory.Faker("date_between", start_date="+30w", end_date="+52w"),
        # otherwise don't set
        no_declaration=None,
    )
    fiscal_year = factory.LazyAttribute(
        lambda s: s.forecasted_project_start_date.year if s.forecasted_project_start_date else None
    )

    is_deleted = False

    # Generally, current summaries won't have the revision number set
    revision_number = None

    version_number = factory.Faker("random_int", min=8, max=13)

    funding_instruments = factory.Faker(
        "random_elements",
        length=random.randint(1, 3),
        elements=[f for f in FundingInstrument],
        unique=True,
    )
    funding_categories = factory.Faker(
        "random_elements",
        length=random.randint(1, 3),
        elements=[f for f in FundingCategory],
        unique=True,
    )
    applicant_types = factory.Faker(
        "random_elements",
        length=random.randint(1, 3),
        elements=[a for a in ApplicantType],
        unique=True,
    )

    created_at = factory.Faker("date_time_between", start_date="-5y", end_date="-3y")
    updated_at = factory.LazyAttribute(
        lambda o: fake.date_time_between(start_date=o.created_at, end_date="-1y")
    )

    class Params:
        # These are common overrides we might want for an opportunity summary.
        # Simply pass the in `trait_name=True` to the factory when making an object
        # and all of these will be set for you, overriding the above defaults
        # See: https://factoryboy.readthedocs.io/en/stable/reference.html#traits

        # The default state of values above assumes an "active" summary that has been
        # posted, so only need to configure the is_forecast field for these two
        is_posted_summary = factory.Trait(is_forecast=False)
        is_forecasted_summary = factory.Trait(is_forecast=True)

        # For these scenarios, adjust a few dates to make more sense
        is_closed_summary = factory.Trait(
            is_forecast=False,
            post_date=factory.Faker("date_between", start_date="-6w", end_date="-5w"),
            close_date=factory.Faker("date_between", start_date="-3w", end_date="-1w"),
        )

        is_archived_non_forecast_summary = factory.Trait(
            is_forecast=False,
            post_date=factory.Faker("date_between", start_date="-6w", end_date="-5w"),
            close_date=factory.Faker("date_between", start_date="-3w", end_date="-2w"),
            archive_date=factory.Faker("date_between", start_date="-2w", end_date="-1w"),
        )
        is_archived_forecast_summary = factory.Trait(
            is_forecast=True,
            post_date=factory.Faker("date_between", start_date="-6w", end_date="-5w"),
            archive_date=factory.Faker("date_between", start_date="-2w", end_date="-1w"),
        )

        is_non_public_non_forecast_summary = factory.Trait(
            is_forecast=False,
            post_date=factory.Faker("date_between", start_date="+3w", end_date="+4w"),
        )
        is_non_public_forecast_summary = factory.Trait(
            is_forecast=True,
            post_date=factory.Faker("date_between", start_date="+3w", end_date="+4w"),
        )

        # Set all nullable fields to null
        all_fields_null = factory.Trait(
            summary_description=None,
            is_cost_sharing=None,
            post_date=None,
            close_date=None,
            close_date_description=None,
            archive_date=None,
            unarchive_date=None,
            expected_number_of_awards=None,
            estimated_total_program_funding=None,
            award_floor=None,
            award_ceiling=None,
            additional_info_url=None,
            additional_info_url_description=None,
            forecasted_post_date=None,
            forecasted_close_date=None,
            forecasted_close_date_description=None,
            forecasted_award_date=None,
            forecasted_project_start_date=None,
            fiscal_year=None,
            modification_comments=None,
            funding_category_description=None,
            applicant_eligibility_description=None,
            agency_code=None,
            agency_name=None,
            agency_phone_number=None,
            agency_contact_description=None,
            agency_email_address=None,
            agency_email_address_description=None,
            is_deleted=None,
            funding_instruments=[],
            funding_categories=[],
            applicant_types=[],
        )

        no_link_values = factory.Trait(
            link_funding_instruments=[],
            link_funding_categories=[],
            link_applicant_types=[],
        )


class CurrentOpportunitySummaryFactory(BaseFactory):
    class Meta:
        model = opportunity_models.CurrentOpportunitySummary

    opportunity = factory.SubFactory(OpportunityFactory)
    opportunity_id = factory.LazyAttribute(lambda a: a.opportunity.opportunity_id)

    opportunity_summary = factory.SubFactory(
        OpportunitySummaryFactory, opportunity=factory.SelfAttribute("..opportunity")
    )
    opportunity_summary_id = factory.LazyAttribute(
        lambda a: a.opportunity_summary.opportunity_summary_id
    )

    opportunity_status = OpportunityStatus.POSTED

    class Params:
        is_posted_summary = factory.Trait(
            opportunity_status=OpportunityStatus.POSTED, opportunity_summary__is_posted_summary=True
        )
        is_forecasted_summary = factory.Trait(
            opportunity_status=OpportunityStatus.FORECASTED,
            opportunity_summary__is_forecasted_summary=True,
        )
        is_closed_summary = factory.Trait(
            opportunity_status=OpportunityStatus.CLOSED, opportunity_summary__is_closed_summary=True
        )
        is_archived_non_forecast_summary = factory.Trait(
            opportunity_status=OpportunityStatus.ARCHIVED,
            opportunity_summary__is_archived_non_forecast_summary=True,
        )
        is_archived_forecast_summary = factory.Trait(
            opportunity_status=OpportunityStatus.ARCHIVED,
            opportunity_summary__is_archived_forecast_summary=True,
        )


class OpportunityAssistanceListingFactory(BaseFactory):
    class Meta:
        model = opportunity_models.OpportunityAssistanceListing

    @classmethod
    def _setup_next_sequence(cls):
        if _db_session is not None:
            value = _db_session.query(
                func.max(
                    opportunity_models.OpportunityAssistanceListing.opportunity_assistance_listing_id
                )
            ).scalar()
            if value is not None:
                return value + 1

        return 1

    opportunity_assistance_listing_id = factory.Sequence(lambda n: n)

    opportunity = factory.SubFactory(OpportunityFactory)
    opportunity_id = factory.LazyAttribute(lambda a: a.opportunity.opportunity_id)

    program_title = factory.Faker("company")
    assistance_listing_number = factory.LazyFunction(
        lambda: f"{fake.random_int(min=1, max=99):02}.{fake.random_int(min=1, max=999):03}"
    )

    class Params:
        # Set the timestamps in the past rather than using the default of "now"
        timestamps_in_past = factory.Trait(
            created_at=factory.Faker("date_time_between", start_date="-5y", end_date="-3y"),
            updated_at=factory.Faker("date_time_between", start_date="-3y", end_date="-1y"),
        )


class LinkOpportunitySummaryFundingInstrumentFactory(BaseFactory):
    class Meta:
        model = opportunity_models.LinkOpportunitySummaryFundingInstrument

    opportunity_summary = factory.SubFactory(OpportunitySummaryFactory)
    opportunity_summary_id = factory.LazyAttribute(
        lambda f: f.opportunity_summary.opportunity_summary_id
    )

    # We use an iterator here to keep the values unique when generated by the opportunity factory
    funding_instrument = factory.Iterator(FundingInstrument)


class LinkOpportunitySummaryFundingCategoryFactory(BaseFactory):
    class Meta:
        model = opportunity_models.LinkOpportunitySummaryFundingCategory

    opportunity_summary = factory.SubFactory(OpportunitySummaryFactory)
    opportunity_summary_id = factory.LazyAttribute(
        lambda f: f.opportunity_summary.opportunity_summary_id
    )

    # We use an iterator here to keep the values unique when generated by the opportunity factory
    funding_category = factory.Iterator(FundingCategory)


class LinkOpportunitySummaryApplicantTypeFactory(BaseFactory):
    class Meta:
        model = opportunity_models.LinkOpportunitySummaryApplicantType

    opportunity_summary = factory.SubFactory(OpportunitySummaryFactory)
    opportunity_summary_id = factory.LazyAttribute(
        lambda f: f.opportunity_summary.opportunity_summary_id
    )

    # We use an iterator here to keep the values unique when generated by the opportunity factory
    applicant_type = factory.Iterator(ApplicantType)


class AgencyContactInfoFactory(BaseFactory):
    class Meta:
        model = agency_models.AgencyContactInfo

    contact_name = factory.Faker("name")
    address_line_1 = factory.Faker("street_address")
    address_line_2 = sometimes_none(factory.Sequence(lambda n: f"Room {n}"))
    city = factory.Faker("city")
    state = factory.Faker("state_abbr")
    zip_code = factory.Faker("street_address")
    phone_number = factory.Faker("basic_phone_number")
    primary_email = factory.Faker("email")
    secondary_email = sometimes_none(factory.Faker("email"))


class AgencyFactory(BaseFactory):
    class Meta:
        model = agency_models.Agency

    agency_name = factory.Faker("agency_name")

    agency_code = factory.Faker("agency")
    sub_agency_code = factory.LazyAttribute(lambda a: a.agency_code.split("-")[0])

    assistance_listing_number = factory.Faker("random_int", min=1, max=999)

    agency_submission_notification_setting = factory.fuzzy.FuzzyChoice(
        AgencySubmissionNotificationSetting
    )

    agency_contact_info = factory.SubFactory(AgencyContactInfoFactory)
    agency_contact_info_id = factory.LazyAttribute(
        lambda a: a.agency_contact_info.agency_contact_info_id if a.agency_contact_info else None
    )

    is_test_agency = False

    ldap_group = factory.LazyAttribute(lambda a: a.agency_code)
    description = factory.LazyAttribute(lambda a: a.agency_name)
    label = factory.LazyAttribute(lambda a: a.agency_name)
    is_multilevel_agency = factory.Faker("boolean")
    is_multiproject = factory.Faker("boolean")
    has_system_to_system_certificate = factory.Faker("boolean")
    can_view_packages_in_grace_period = factory.Faker("boolean")
    is_image_workspace_enabled = factory.Faker("boolean")
    is_validation_workspace_enabled = factory.Faker("boolean")

    agency_download_file_types = factory.Faker(
        "random_elements",
        length=random.randint(1, 2),
        elements=[a for a in AgencyDownloadFileType],
        unique=True,
    )


####################################
# Staging Table Factories
####################################

LEGACY_APPLICANT_TYPE_IDS = [
    "00",
    "01",
    "02",
    "04",
    "05",
    "06",
    "07",
    "08",
    "11",
    "12",
    "13",
    "20",
    "21",
    "22",
    "23",
    "25",
    "99",
]
LEGACY_FUNDING_CATEGORY_IDS = [
    "RA",
    "AG",
    "AR",
    "BC",
    "CD",
    "CP",
    "DPR",
    "ED",
    "ELT",
    "EN",
    "ENV",
    "FN",
    "HL",
    "HO",
    "HU",
    "IIJ",
    "IS",
    "ISS",
    "LJL",
    "NR",
    "OZ",
    "RD",
    "ST",
    "T",
    "ACA",
    "O",
]
LEGACY_FUNDING_INSTRUMENT_IDS = ["CA", "G", "PC", "O"]


class StagingTopportunityFactory(BaseFactory):
    class Meta:
        model = staging.opportunity.Topportunity

    opportunity_id = factory.Sequence(lambda n: n)

    oppnumber = factory.Faker("opportunity_number")
    opptitle = factory.Faker("opportunity_title")

    owningagency = factory.Faker("agency")

    oppcategory = factory.fuzzy.FuzzyChoice(OpportunityCategoryLegacy)
    # only set the category explanation if category is Other
    category_explanation = factory.Maybe(
        decider=factory.LazyAttribute(lambda o: o.oppcategory == OpportunityCategoryLegacy.OTHER),
        yes_declaration=factory.Faker("sentence", nb_words=5),
        no_declaration=None,
    )

    is_draft = factory.fuzzy.FuzzyChoice(["N", "S"])

    revision_number = factory.Faker("random_int", min=1, max=10)

    created_date = factory.Faker("date_time_between", start_date="-10y", end_date="-5y")
    last_upd_date = sometimes_none(
        factory.Faker("date_time_between", start_date="-5y", end_date="now")
    )

    # Default to being a new insert/update
    is_deleted = False
    transformed_at = None

    cfdas = factory.RelatedFactoryList(
        "tests.src.db.models.factories.StagingTopportunityCfdaFactory",
        factory_related_name="opportunity",
        size=lambda: random.randint(1, 3),
    )

    class Params:
        already_transformed = factory.Trait(
            transformed_at=factory.Faker("date_time_between", start_date="-7d", end_date="-1d")
        )

        # Trait to set all nullable fields to None
        all_fields_null = factory.Trait(
            oppnumber=None,
            revision_number=None,
            opptitle=None,
            owningagency=None,
            oppcategory=None,
            category_explanation=None,
        )


class StagingTopportunityCfdaFactory(BaseFactory):
    class Meta:
        model = staging.opportunity.TopportunityCfda

    opp_cfda_id = factory.Sequence(lambda n: n)

    opportunity = factory.SubFactory(StagingTopportunityFactory)
    opportunity_id = factory.LazyAttribute(lambda s: s.opportunity.opportunity_id)

    programtitle = factory.Faker("company")
    cfdanumber = factory.LazyFunction(
        lambda: f"{fake.random_int(min=1, max=99):02}.{fake.random_int(min=1, max=999):03}"
    )

    created_date = factory.Faker("date_time_between", start_date="-10y", end_date="-5y")
    last_upd_date = sometimes_none(
        factory.Faker("date_time_between", start_date="-5y", end_date="now")
    )

    # Default to being a new insert/update
    is_deleted = False
    transformed_at = None

    class Params:
        already_transformed = factory.Trait(
            transformed_at=factory.Faker("date_time_between", start_date="-7d", end_date="-1d")
        )

        # Trait to set all nullable fields to None
        all_fields_null = factory.Trait(
            programtitle=None,
            cfdanumber=None,
        )


class StagingTsynopsisFactory(BaseFactory):
    class Meta:
        model = staging.synopsis.Tsynopsis

    opportunity = factory.SubFactory(StagingTopportunityFactory)
    opportunity_id = factory.LazyAttribute(lambda s: s.opportunity.opportunity_id)

    posting_date = factory.Faker("date_between", start_date="-3w", end_date="now")
    response_date = factory.Faker("date_between", start_date="+2w", end_date="+3w")
    archive_date = factory.Faker("date_between", start_date="+3w", end_date="+4w")
    unarchive_date = sometimes_none(
        factory.Faker("date_between", start_date="+6w", end_date="+7w"), none_chance=0.9
    )
    syn_desc = factory.Faker("summary_description")
    oth_cat_fa_desc = sometimes_none(factory.Faker("paragraph", nb_sentences=1))

    cost_sharing = sometimes_none(factory.Faker("yn_yesno_boolean"), none_chance=0.1)
    # These int values are stored as strings
    number_of_awards = sometimes_none(
        factory.LazyFunction(lambda: str(fake.random_int(1, 25))), none_chance=0.1
    )
    est_funding = sometimes_none(
        factory.LazyFunction(lambda: str(fake.random_int(25_000, 25_000_000, step=5_000))),
        none_chance=0.1,
    )
    award_ceiling = sometimes_none(
        factory.LazyFunction(lambda: str(fake.random_int(10_000, 25_000, step=5_000))),
        none_chance=0.1,
    )
    award_floor = sometimes_none(
        factory.LazyFunction(lambda: str(fake.random_int(0, 10_000, step=5_000))), none_chance=0.1
    )

    fd_link_url = factory.Faker("relevant_url")
    fd_link_desc = factory.Faker("additional_info_desc")
    agency_contact_desc = factory.Faker("agency_contact_description")
    ac_email_addr = factory.Faker("email")
    ac_email_desc = factory.LazyAttribute(lambda s: f"Contact {s.ac_name} via email")
    a_sa_code = factory.Faker("agency")
    ac_phone_number = Generators.PhoneNumber
    ac_name = factory.Faker("agency_name")

    created_date = factory.Faker("date_time_between", start_date="-10y", end_date="-5y")
    last_upd_date = sometimes_none(
        factory.Faker("date_time_between", start_date="-5y", end_date="now")
    )
    create_ts = factory.Faker("date_time_between", start_date="-10y", end_date="-5y")
    sendmail = sometimes_none(factory.Faker("yn_yesno_boolean"))
    response_date_desc = sometimes_none(factory.Faker("paragraph", nb_sentences=2))
    applicant_elig_desc = sometimes_none(factory.Faker("paragraph", nb_sentences=5))
    version_nbr = factory.Faker("random_int", min=0, max=10)
    modification_comments = sometimes_none(factory.Faker("paragraph", nb_sentences=1))
    publisheruid = sometimes_none(factory.Faker("first_name"))
    publisher_profile_id = sometimes_none(factory.Faker("random_int", min=1, max=99_999))

    # Default to being a new insert/update
    is_deleted = False
    transformed_at = None

    class Params:
        already_transformed = factory.Trait(
            transformed_at=factory.Faker("date_time_between", start_date="-7d", end_date="-1d")
        )


class StagingTsynopsisHistFactory(StagingTsynopsisFactory):
    class Meta:
        model = staging.synopsis.TsynopsisHist

    revision_number = factory.Faker("random_int", min=1, max=25)
    action_type = "U"  # Update, put D for deleted

    class Params:
        already_transformed = factory.Trait(
            transformed_at=factory.Faker("date_time_between", start_date="-7d", end_date="-1d")
        )


class StagingTforecastFactory(BaseFactory):
    class Meta:
        model = staging.forecast.Tforecast

    opportunity = factory.SubFactory(StagingTopportunityFactory)
    opportunity_id = factory.LazyAttribute(lambda s: s.opportunity.opportunity_id)

    posting_date = factory.Faker("date_between", start_date="-3w", end_date="now")
    archive_date = factory.Faker("date_between", start_date="+3w", end_date="+4w")
    forecast_desc = factory.Faker("summary_description")
    oth_cat_fa_desc = sometimes_none(factory.Faker("paragraph", nb_sentences=1))

    cost_sharing = sometimes_none(factory.Faker("yn_yesno_boolean"), none_chance=0.1)
    # These int values are stored as strings
    number_of_awards = sometimes_none(
        factory.LazyFunction(lambda: str(fake.random_int(1, 25))), none_chance=0.1
    )
    est_funding = sometimes_none(
        factory.LazyFunction(lambda: str(fake.random_int(25_000, 25_000_000, step=5_000))),
        none_chance=0.1,
    )
    award_ceiling = sometimes_none(
        factory.LazyFunction(lambda: str(fake.random_int(10_000, 25_000, step=5_000))),
        none_chance=0.1,
    )
    award_floor = sometimes_none(
        factory.LazyFunction(lambda: str(fake.random_int(0, 10_000, step=5_000))), none_chance=0.1
    )

    fd_link_url = factory.Faker("relevant_url")
    fd_link_desc = factory.Faker("additional_info_desc")
    ac_email_addr = factory.Faker("email")
    ac_email_desc = factory.LazyAttribute(lambda s: f"Contact {s.ac_name} via email")
    agency_code = factory.Faker("agency")
    ac_phone = Generators.PhoneNumber
    ac_name = factory.Faker("agency_name")

    created_date = factory.Faker("date_time_between", start_date="-10y", end_date="-5y")
    last_upd_date = sometimes_none(
        factory.Faker("date_time_between", start_date="-5y", end_date="now")
    )
    create_ts = factory.Faker("date_time_between", start_date="-10y", end_date="-5y")
    sendmail = sometimes_none(factory.Faker("yn_yesno_boolean"))
    applicant_elig_desc = sometimes_none(factory.Faker("paragraph", nb_sentences=5))
    version_nbr = factory.Faker("random_int", min=0, max=10)
    modification_comments = sometimes_none(factory.Faker("paragraph", nb_sentences=1))
    publisheruid = sometimes_none(factory.Faker("first_name"))
    publisher_profile_id = sometimes_none(factory.Faker("random_int", min=1, max=99_999))

    est_synopsis_posting_date = sometimes_none(
        factory.Faker("date_between", start_date="+2w", end_date="+3w")
    )
    est_appl_response_date = sometimes_none(
        factory.Faker("date_between", start_date="+4w", end_date="+6w")
    )
    est_appl_response_date_desc = sometimes_none(factory.Faker("paragraph", nb_sentences=1))
    est_award_date = sometimes_none(
        factory.Faker("date_between", start_date="+26w", end_date="+30w")
    )
    est_project_start_date = sometimes_none(
        factory.Faker("date_between", start_date="+30w", end_date="+52w")
    )
    fiscal_year = factory.LazyAttribute(
        lambda f: f.est_project_start_date.year if f.est_project_start_date else None
    )

    # Default to being a new insert/update
    is_deleted = False
    transformed_at = None

    class Params:
        already_transformed = factory.Trait(
            transformed_at=factory.Faker("date_time_between", start_date="-7d", end_date="-1d")
        )


class StagingTforecastHistFactory(StagingTforecastFactory):
    class Meta:
        model = staging.forecast.TforecastHist

    revision_number = factory.Faker("random_int", min=1, max=25)
    action_type = "U"  # Update, put D for deleted

    class Params:
        already_transformed = factory.Trait(
            transformed_at=factory.Faker("date_time_between", start_date="-7d", end_date="-1d")
        )


class StagingTapplicanttypesForecastFactory(BaseFactory):
    class Meta:
        model = staging.forecast.TapplicanttypesForecast

    at_frcst_id = factory.Sequence(lambda n: n)

    at_id = factory.Iterator(LEGACY_APPLICANT_TYPE_IDS)

    forecast = factory.SubFactory(StagingTforecastFactory)
    opportunity_id = factory.LazyAttribute(lambda s: s.forecast.opportunity_id)

    # Default to being a new insert/update
    is_deleted = False
    transformed_at = None

    created_date = factory.Faker("date_time_between", start_date="-10y", end_date="-5y")
    last_upd_date = sometimes_none(
        factory.Faker("date_time_between", start_date="-5y", end_date="now")
    )

    last_upd_id = factory.Faker("first_name")
    creator_id = factory.Faker("first_name")

    class Params:
        already_transformed = factory.Trait(
            transformed_at=factory.Faker("date_time_between", start_date="-7d", end_date="-1d")
        )

        orphaned_record = factory.Trait(
            forecast=None, opportunity_id=factory.Faker("random_int", min=10_000, max=50_000)
        )


class StagingTapplicanttypesForecastHistFactory(StagingTapplicanttypesForecastFactory):
    class Meta:
        model = staging.forecast.TapplicanttypesForecastHist

    forecast = factory.SubFactory(StagingTforecastHistFactory)
    opportunity_id = factory.LazyAttribute(lambda s: s.forecast.opportunity_id)
    revision_number = factory.LazyAttribute(lambda s: s.forecast.revision_number)

    class Params:
        already_transformed = factory.Trait(
            transformed_at=factory.Faker("date_time_between", start_date="-7d", end_date="-1d")
        )


class StagingTapplicanttypesSynopsisFactory(BaseFactory):
    class Meta:
        model = staging.synopsis.TapplicanttypesSynopsis

    at_syn_id = factory.Sequence(lambda n: n)

    at_id = factory.Iterator(LEGACY_APPLICANT_TYPE_IDS)

    synopsis = factory.SubFactory(StagingTsynopsisFactory)
    opportunity_id = factory.LazyAttribute(lambda s: s.synopsis.opportunity_id)

    # Default to being a new insert/update
    is_deleted = False
    transformed_at = None

    created_date = factory.Faker("date_time_between", start_date="-10y", end_date="-5y")
    last_upd_date = sometimes_none(
        factory.Faker("date_time_between", start_date="-5y", end_date="now")
    )

    creator_id = factory.Faker("first_name")
    last_upd_id = factory.Faker("first_name")

    class Params:
        already_transformed = factory.Trait(
            transformed_at=factory.Faker("date_time_between", start_date="-7d", end_date="-1d")
        )

        orphaned_record = factory.Trait(
            synopsis=None, opportunity_id=factory.Faker("random_int", min=10_000, max=50_000)
        )


class StagingTapplicanttypesSynopsisHistFactory(StagingTapplicanttypesSynopsisFactory):
    class Meta:
        model = staging.synopsis.TapplicanttypesSynopsisHist

    synopsis = factory.SubFactory(StagingTsynopsisHistFactory)
    opportunity_id = factory.LazyAttribute(lambda s: s.synopsis.opportunity_id)
    revision_number = factory.LazyAttribute(lambda s: s.synopsis.revision_number)

    class Params:
        already_transformed = factory.Trait(
            transformed_at=factory.Faker("date_time_between", start_date="-7d", end_date="-1d")
        )


class StagingTfundactcatForecastFactory(BaseFactory):
    class Meta:
        model = staging.forecast.TfundactcatForecast

    fac_frcst_id = factory.Sequence(lambda n: n)

    fac_id = factory.Iterator(LEGACY_FUNDING_CATEGORY_IDS)

    forecast = factory.SubFactory(StagingTforecastFactory)
    opportunity_id = factory.LazyAttribute(lambda s: s.forecast.opportunity_id)

    # Default to being a new insert/update
    is_deleted = False
    transformed_at = None

    created_date = factory.Faker("date_time_between", start_date="-10y", end_date="-5y")
    last_upd_date = sometimes_none(
        factory.Faker("date_time_between", start_date="-5y", end_date="now")
    )

    creator_id = factory.Faker("first_name")
    last_upd_id = factory.Faker("first_name")

    class Params:
        already_transformed = factory.Trait(
            transformed_at=factory.Faker("date_time_between", start_date="-7d", end_date="-1d")
        )

        orphaned_record = factory.Trait(
            forecast=None, opportunity_id=factory.Faker("random_int", min=10_000, max=50_000)
        )


class StagingTfundactcatForecastHistFactory(StagingTfundactcatForecastFactory):
    class Meta:
        model = staging.forecast.TfundactcatForecastHist

    forecast = factory.SubFactory(StagingTforecastHistFactory)
    opportunity_id = factory.LazyAttribute(lambda s: s.forecast.opportunity_id)
    revision_number = factory.LazyAttribute(lambda s: s.forecast.revision_number)

    class Params:
        already_transformed = factory.Trait(
            transformed_at=factory.Faker("date_time_between", start_date="-7d", end_date="-1d")
        )


class StagingTfundactcatSynopsisFactory(BaseFactory):
    class Meta:
        model = staging.synopsis.TfundactcatSynopsis

    fac_syn_id = factory.Sequence(lambda n: n)

    fac_id = factory.Iterator(LEGACY_FUNDING_CATEGORY_IDS)

    synopsis = factory.SubFactory(StagingTsynopsisFactory)
    opportunity_id = factory.LazyAttribute(lambda s: s.synopsis.opportunity_id)

    # Default to being a new insert/update
    is_deleted = False
    transformed_at = None

    created_date = factory.Faker("date_time_between", start_date="-10y", end_date="-5y")
    last_upd_date = sometimes_none(
        factory.Faker("date_time_between", start_date="-5y", end_date="now")
    )

    creator_id = factory.Faker("first_name")
    last_upd_id = factory.Faker("first_name")

    class Params:
        already_transformed = factory.Trait(
            transformed_at=factory.Faker("date_time_between", start_date="-7d", end_date="-1d")
        )

        orphaned_record = factory.Trait(
            synopsis=None, opportunity_id=factory.Faker("random_int", min=10_000, max=50_000)
        )


class StagingTfundactcatSynopsisHistFactory(StagingTfundactcatSynopsisFactory):
    class Meta:
        model = staging.synopsis.TfundactcatSynopsisHist

    synopsis = factory.SubFactory(StagingTsynopsisHistFactory)
    opportunity_id = factory.LazyAttribute(lambda s: s.synopsis.opportunity_id)
    revision_number = factory.LazyAttribute(lambda s: s.synopsis.revision_number)

    class Params:
        already_transformed = factory.Trait(
            transformed_at=factory.Faker("date_time_between", start_date="-7d", end_date="-1d")
        )


class StagingTfundinstrForecastFactory(BaseFactory):
    class Meta:
        model = staging.forecast.TfundinstrForecast

    fi_frcst_id = factory.Sequence(lambda n: n)

    fi_id = factory.Iterator(LEGACY_FUNDING_INSTRUMENT_IDS)

    forecast = factory.SubFactory(StagingTforecastFactory)
    opportunity_id = factory.LazyAttribute(lambda s: s.forecast.opportunity_id)

    # Default to being a new insert/update
    is_deleted = False
    transformed_at = None

    created_date = factory.Faker("date_time_between", start_date="-10y", end_date="-5y")
    last_upd_date = sometimes_none(
        factory.Faker("date_time_between", start_date="-5y", end_date="now")
    )

    creator_id = factory.Faker("first_name")
    last_upd_id = factory.Faker("first_name")

    class Params:
        already_transformed = factory.Trait(
            transformed_at=factory.Faker("date_time_between", start_date="-7d", end_date="-1d")
        )

        orphaned_record = factory.Trait(
            forecast=None, opportunity_id=factory.Faker("random_int", min=10_000, max=50_000)
        )


class StagingTfundinstrForecastHistFactory(StagingTfundinstrForecastFactory):
    class Meta:
        model = staging.forecast.TfundinstrForecastHist

    forecast = factory.SubFactory(StagingTforecastHistFactory)
    opportunity_id = factory.LazyAttribute(lambda s: s.forecast.opportunity_id)
    revision_number = factory.LazyAttribute(lambda s: s.forecast.revision_number)

    class Params:
        already_transformed = factory.Trait(
            transformed_at=factory.Faker("date_time_between", start_date="-7d", end_date="-1d")
        )


class StagingTfundinstrSynopsisFactory(BaseFactory):
    class Meta:
        model = staging.synopsis.TfundinstrSynopsis

    fi_syn_id = factory.Sequence(lambda n: n)

    fi_id = factory.Iterator(LEGACY_FUNDING_INSTRUMENT_IDS)

    synopsis = factory.SubFactory(StagingTsynopsisFactory)
    opportunity_id = factory.LazyAttribute(lambda s: s.synopsis.opportunity_id)

    # Default to being a new insert/update
    is_deleted = False
    transformed_at = None

    created_date = factory.Faker("date_time_between", start_date="-10y", end_date="-5y")
    last_upd_date = sometimes_none(
        factory.Faker("date_time_between", start_date="-5y", end_date="now")
    )

    creator_id = factory.Faker("first_name")
    last_upd_id = factory.Faker("first_name")

    class Params:
        already_transformed = factory.Trait(
            transformed_at=factory.Faker("date_time_between", start_date="-7d", end_date="-1d")
        )

        orphaned_record = factory.Trait(
            synopsis=None, opportunity_id=factory.Faker("random_int", min=10_000, max=50_000)
        )


class StagingTfundinstrSynopsisHistFactory(StagingTfundinstrSynopsisFactory):
    class Meta:
        model = staging.synopsis.TfundinstrSynopsisHist

    synopsis = factory.SubFactory(StagingTsynopsisHistFactory)
    opportunity_id = factory.LazyAttribute(lambda s: s.synopsis.opportunity_id)
    revision_number = factory.LazyAttribute(lambda s: s.synopsis.revision_number)

    class Params:
        already_transformed = factory.Trait(
            transformed_at=factory.Faker("date_time_between", start_date="-7d", end_date="-1d")
        )


class StagingTgroupsFactory(BaseFactory):
    class Meta:
        model = staging.tgroups.Tgroups

    keyfield = ""
    value = ""

    is_deleted = False

    created_date = factory.Faker("date_time_between", start_date="-10y", end_date="-5y")
    last_upd_date = sometimes_none(
        factory.Faker("date_time_between", start_date="-5y", end_date="now")
    )

    last_upd_id = factory.Faker("first_name")
    creator_id = factory.Faker("first_name")

    class Params:
        already_transformed = factory.Trait(
            transformed_at=factory.Faker("date_time_between", start_date="-7d", end_date="-1d")
        )


####################################
# Transfer Table Factories
####################################


class TransferTopportunityFactory(BaseFactory):
    class Meta:
        model = transfer_topportunity_models.TransferTopportunity

    opportunity_id = factory.Sequence(lambda n: n)

    oppnumber = factory.Sequence(lambda n: f"ABC-{n}-XYZ-001")
    opptitle = factory.LazyFunction(lambda: f"Detailed research into {fake.job()} industry")

    owningagency = factory.Faker("agency")

    oppcategory = factory.fuzzy.FuzzyChoice(OpportunityCategoryLegacy)
    # only set the category explanation if category is Other
    category_explanation = factory.Maybe(
        decider=factory.LazyAttribute(lambda o: o.oppcategory == OpportunityCategoryLegacy.OTHER),
        yes_declaration=factory.Sequence(lambda n: f"Category as chosen by order #{n * n - 1}"),
        no_declaration=None,
    )

    is_draft = "N"  # Because we filter out drafts, just default these to False

    revision_number = 0

    # Make sure updated_at is after created_at just to make the data realistic
    created_at = factory.Faker("date_time")
    updated_at = factory.LazyAttribute(
        lambda o: fake.date_time_between(start_date=o.created_at, end_date="now")
    )

    created_date = factory.LazyAttribute(lambda o: o.created_at.date())
    last_upd_date = factory.LazyAttribute(lambda o: o.updated_at.date())


####################################
# Foreign Table Factories
####################################


class ForeignTopportunityFactory(factory.DictFactory):
    """
    NOTE: This generates a dictionary - and does not connect to the database directly
    """

    opportunity_id = factory.Sequence(lambda n: n)

    oppnumber = factory.Sequence(lambda n: f"F-ABC-{n}-XYZ-001")
    opptitle = factory.LazyFunction(lambda: f"Research into {fake.job()} industry".replace("'", ""))

    owningagency = factory.Iterator(["F-US-ABC", "F-US-XYZ", "F-US-123"])

    oppcategory = factory.fuzzy.FuzzyChoice(OpportunityCategoryLegacy)
    # only set the category explanation if category is Other
    category_explanation = factory.Maybe(
        decider=factory.LazyAttribute(lambda o: o.oppcategory == OpportunityCategoryLegacy.OTHER),
        yes_declaration=factory.Sequence(lambda n: f"Category as chosen by order #{n * n - 1}"),
        no_declaration=None,
    )

    is_draft = "N"  # Because we filter out drafts, just default these to False

    revision_number = 0

    created_date = factory.Faker("date_between", start_date="-10y", end_date="-5y")
    last_upd_date = factory.Faker("date_between", start_date="-5y", end_date="today")


##
# Pseudo-factories
##


class OpportunitySummaryHistoryBuilder:
    """dasdasd
    Utility class for adding historical opportunity summary records
    to an opportunity.

    Can either take in an existing opportunity or you can pass parameters
    into the init method to create an opportunity using the OpportunityFactory

    For example:

        opportunity = (
            OpportunitySummaryHistoryBuilder(opportunity_title="My opportunity title")
                .add_forecast()
                .add_forecast_history()
                .add_non_forecast(is_current=True)
                .add_non_forecast_history(summary_description="an older description")
                .add_non_forecast_history()
                .build()
        )

    This would produce an opportunity with:
        * A non-forecast summary record set to be the CurrentOpportunitySummary
        * Two prior non-forecast summary records
        * A forecast summary record
        * A forecast summary history record

    """

    def __init__(self, opportunity: opportunity_models.Opportunity | None = None, **kwargs):
        self.opportunity_already_exists: bool = False
        self.forecast_already_exists: bool = False
        self.non_forecast_already_exists: bool = False

        self.most_recent_non_forecast: dict | None = None
        self.most_recent_forecast: dict | None = None

        self.non_forecast_history: list[dict] = []
        self.forecast_history: list[dict] = []

        self.is_current_non_forecast = False
        self.is_current_forecast = False

        if opportunity is None:
            self.opportunity = OpportunityFactory.create(no_current_summary=True, **kwargs)
        else:
            self.opportunity_already_exists = True
            self.opportunity = opportunity
            if opportunity.current_opportunity_summary is not None:
                current_summary = opportunity.current_opportunity_summary.opportunity_summary

                if current_summary.is_forecast:
                    self.most_recent_forecast = current_summary.for_json()
                    self.forecast_already_exists = True
                    self.is_current_forecast = True
                else:
                    self.most_recent_non_forecast = current_summary.for_json()
                    self.non_forecast_already_exists = True
                    self.is_current_non_forecast = True

    def add_non_forecast(
        self, is_current: bool = False, **kwargs
    ) -> "OpportunitySummaryHistoryBuilder":
        if self.most_recent_non_forecast:
            raise Exception("Cannot call add_non_forecast if a non-forecast already exists")

        kwargs["is_forecast"] = False
        self.is_current_non_forecast = is_current
        self.most_recent_non_forecast = kwargs

        return self

    def add_forecast(
        self, is_current: bool = False, **kwargs
    ) -> "OpportunitySummaryHistoryBuilder":
        if self.most_recent_forecast:
            raise Exception("Cannot call add_forecast if a forecast already exists")

        kwargs["is_forecast"] = True
        self.is_current_forecast = is_current
        self.most_recent_forecast = kwargs

        return self

    def add_non_forecast_history(
        self, is_deleted: bool = False, **kwargs
    ) -> "OpportunitySummaryHistoryBuilder":
        # If there is no most_recent_non_forecast set, we want to error
        # unless the record is deleted or the last (first added) history record was deleted.
        #
        # Effectively, you can only have a history without a non-history record
        # if the last history record is deleted. If the last is deleted, you're
        # free to add more history.
        #
        # eg. You can setup a history that is several updates and then someone ultimately deleting the non-forecast
        if self.most_recent_non_forecast is None:
            if not is_deleted and (
                len(self.non_forecast_history) > 0
                and self.non_forecast_history[0].get("is_deleted") is not True
            ):
                raise Exception(
                    "Cannot add a historical non-forecast without already having a regular non-forecast UNLESS the last historical record is deleted"
                )

        kwargs["is_forecast"] = False
        kwargs["is_deleted"] = is_deleted
        self.non_forecast_history.append(kwargs)

        return self

    def add_forecast_history(
        self, is_deleted: bool = False, **kwargs
    ) -> "OpportunitySummaryHistoryBuilder":
        # If there is no most_recent_forecast set, we want to error
        # unless the record is deleted or the last (first added) history record was deleted.
        #
        # Effectively, you can only have a history without a non-history record
        # if the last history record is deleted. If the last is deleted, you're
        # free to add more history.
        #
        # eg. You can setup a history that is several updates and then someone ultimately deleting the forecast
        if self.most_recent_forecast is None:
            if not is_deleted and (
                len(self.forecast_history) > 0
                and self.forecast_history[0].get("is_deleted") is not True
            ):
                raise Exception(
                    "Cannot add a historical forecast without already having a regular forecast UNLESS the last historical record is deleted"
                )

        kwargs["is_forecast"] = True
        kwargs["is_deleted"] = is_deleted
        self.forecast_history.append(kwargs)

        return self

    def build(self) -> opportunity_models.Opportunity:
        if self.is_current_non_forecast and self.is_current_forecast:
            raise Exception(
                "Cannot set both the forecast and non-forecast record to be the CurrentOpportunitySummary"
            )

        non_forecast_hist_count = len(self.non_forecast_history)
        forecast_hist_count = len(self.forecast_history)

        # revision number behaves sorta like
        # a "global" count shared by all historical records
        revision_number = non_forecast_hist_count + forecast_hist_count - 1

        non_forecast_params: dict = {}
        forecast_params: dict = {}

        if self.non_forecast_already_exists is False and self.most_recent_non_forecast is not None:
            non_forecast = OpportunitySummaryFactory.create(
                opportunity=self.opportunity,
                version_number=non_forecast_hist_count + 1,
                revision_number=None,
                **self.most_recent_non_forecast,
            )

            non_forecast_params = non_forecast.for_json()

            if self.is_current_non_forecast:
                CurrentOpportunitySummaryFactory.create(
                    opportunity=self.opportunity, opportunity_summary=non_forecast
                )

        if self.non_forecast_already_exists:
            # Adjust the version number to make sense
            self.opportunity.current_opportunity_summary.opportunity_summary.version_number = (
                non_forecast_hist_count + 1
            )

        if self.forecast_already_exists is False and self.most_recent_forecast is not None:
            forecast = OpportunitySummaryFactory.create(
                opportunity=self.opportunity,
                version_number=forecast_hist_count + 1,
                revision_number=None,
                **self.most_recent_forecast,
            )

            forecast_params = forecast.for_json()

            if self.is_current_forecast:
                CurrentOpportunitySummaryFactory.create(
                    opportunity=self.opportunity, opportunity_summary=forecast
                )

        if self.forecast_already_exists:
            # Adjust the version number to make sense
            self.opportunity.current_opportunity_summary.opportunity_summary.version_number = (
                forecast_hist_count + 1
            )

        for non_forecast_hist in self.non_forecast_history:
            params = non_forecast_params | non_forecast_hist

            params.pop("opportunity_summary_id", None)
            params["revision_number"] = revision_number
            params["version_number"] = non_forecast_hist_count
            params["is_deleted"] = non_forecast_hist.get("is_deleted")

            non_forecast_hist = OpportunitySummaryFactory.create(
                opportunity=self.opportunity, **params
            )

            non_forecast_params = non_forecast_hist.for_json()

            non_forecast_hist_count -= 1
            revision_number -= 1

        for forecast_hist in self.forecast_history:
            params = forecast_params | forecast_hist

            params.pop("opportunity_summary_id", None)
            params["revision_number"] = revision_number
            params["version_number"] = forecast_hist_count
            params["is_deleted"] = forecast_hist.get("is_deleted")

            forecast_hist = OpportunitySummaryFactory.create(opportunity=self.opportunity, **params)

            forecast_params = forecast_hist.for_json()

            forecast_hist_count -= 1
            revision_number -= 1

        return self.opportunity


class StagingTgroupsAgencyFactory(factory.DictFactory):
    """
        This does not need to be called directly, and instead you should use
    create_tgroups_agency (defined below) in order to call this.

    We use this to help organize factories / the ability to override and set
    values for the tgroups agency data which is spread across many rows.

    Note: Any value that is "None" will not be included in the created
          tgroups records (empty strings, or strings of values like "null" will be)
    """

    AgencyName = factory.Faker("agency_name")
    AgencyCode = ""  # see: create_tgroups_agency for how this gets set
    AgencyCFDA = factory.Faker("random_int", min=1, max=99)
    AgencyDownload = factory.Faker("random_int", min=1, max=3)
    AgencyNotify = factory.Faker("random_int", min=1, max=3)
    AgencyEnroll = ""  # see: create_tgroups_agency for how this gets set

    AgencyContactName = factory.Faker("name")
    AgencyContactAddress1 = factory.Faker("street_address")
    AgencyContactAddress2 = factory.Maybe(
        decider=factory.LazyAttribute(lambda s: random.random() > 0.5),
        yes_declaration=factory.Sequence(lambda n: f"Room {n}"),
        no_declaration="NULL",
    )
    AgencyContactCity = factory.Faker("city")
    AgencyContactState = factory.Faker("state_abbr")
    AgencyContactZipCode = factory.Faker("postcode")
    AgencyContactTelephone = Generators.PhoneNumber
    AgencyContactEMail = factory.Faker("email")
    AgencyContactEMail2 = sometimes_none(factory.Faker("email"))

    ldapGp = ""  # see: create_tgroups_agency for how this gets set
    description = factory.LazyAttribute(lambda g: g.AgencyName)
    label = factory.LazyAttribute(lambda g: g.AgencyName)
    multilevel = sometimes_none("TRUE", none_chance=0.8)

    HasS2SCert = sometimes_none(factory.Faker("yn_boolean"), none_chance=0.8)
    ViewPkgsInGracePeriod = sometimes_none(factory.Faker("yn_boolean"), none_chance=0.8)
    multiproject = sometimes_none(factory.Faker("yn_boolean"), none_chance=0.8)
    ImageWS = sometimes_none(factory.Faker("yn_boolean"), none_chance=0.8)
    ValidationWS = sometimes_none(factory.Faker("yn_boolean"), none_chance=0.8)


def create_tgroups_agency(
    agency_code: str,
    is_deleted: bool = False,
    is_already_processed: bool = False,
    deleted_fields: set | None = None,
    already_processed_fields: set | None = None,
    **kwargs,
) -> list[staging.tgroups.Tgroups]:
    # The agency_code value is actually just the first bit (the top-level agency)
    kwargs["AgencyCode"] = agency_code.split("-")[0]
    kwargs["AgencyEnroll"] = agency_code
    kwargs["ldapGp"] = agency_code

    field_values = StagingTgroupsAgencyFactory.build(**kwargs)

    groups = []

    field_prefix = f"Agency-{agency_code}-"

    if already_processed_fields is None:
        already_processed_fields = set()

    if deleted_fields is None:
        deleted_fields = set()

    for field_name, value in field_values.items():
        if value is None:
            continue

        is_field_already_processed = is_already_processed or field_name in already_processed_fields
        is_field_deleted = is_deleted or field_name in deleted_fields

        tgroup = StagingTgroupsFactory.create(
            keyfield=field_prefix + field_name,
            value=str(value),
            is_deleted=is_field_deleted,
            already_transformed=is_field_already_processed,
        )

        groups.append(tgroup)

    return groups
