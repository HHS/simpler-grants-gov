#!/usr/bin/env bash

set -euo pipefail

REGION="us-east-1"
DRY_RUN=false

declare -A active_tags_map

REPOSITORIES=(
    "simpler-grants-gov-api"
    "simpler-grants-gov-analytics"
    "simpler-grants-gov-api"
    "simpler-grants-gov-fluentbit"
    "simpler-grants-gov-frontend"
    "simpler-grants-gov-nofos"
)

while [[ $# -gt 0 ]]; do
    case $1 in
        --dry-run)
            DRY_RUN=true
            shift
            ;;
        *)
            echo "Unknown option: $1"
            echo "Usage: $0 [--dry-run]"
            exit 1
            ;;
    esac
done

# Get all active image tags from ECS task definitions
get_active_tags() {
    echo "Step 1: Identifying active images from ECS task definitions"

    local task_defs
    task_defs=$(aws ecs list-task-definitions \
        --region "$REGION" \
        --status ACTIVE \
        --query 'taskDefinitionArns[]' \
        --output text) || {
            echo "ERROR: Failed to list task definitions"
            exit 1
        }

    local task_def_count
    task_def_count=$(echo "$task_defs" | wc -w | tr -d ' ')
    echo "Found $task_def_count active task definitions"
    echo "Fetching container images ..."

    local all_images
    all_images=$(for task_def_arn in $task_defs; do
        aws ecs describe-task-definition \
            --task-definition "$task_def_arn" \
            --region "$REGION" \
            --query 'taskDefinition.containerDefinitions[].image' \
            --output json 2>/dev/null || echo "[]"
    done | jq -s 'add | unique | .[]' -r)

    local tag_count=0
    while IFS= read -r image_url || [ -n "$image_url" ]; do
        [ -z "$image_url" ] && continue

        local repo
        local tag
        repo=""
        tag=""

        # check sha256 image tags
        if [[ $image_url =~ /([^/@:]+)@sha256:([a-f0-9]+)$ ]]; then
            repo="${BASH_REMATCH[1]}"
            tag="sha256:${BASH_REMATCH[2]}"
        # check regular image tags
        elif [[ $image_url =~ /([^/@:]+):([^@:]+)$ ]]; then
            repo="${BASH_REMATCH[1]}"
            tag="${BASH_REMATCH[2]}"
        # Skip plain repo names or unparseable URLs
        else
            continue
        fi

        if [ -z "$repo" ] || [ -z "$tag" ]; then
            continue
        fi


        local repo_tag="$repo:$tag"
        active_tags_map["$repo_tag"]=1
        ((tag_count++)) || true
    done <<< "$all_images"

    echo "Found $tag_count unique active image tags"
}

is_tag_active() {
    local repo_name=$1
    local tag=$2
    local repo_tag="$repo_name:$tag"

    [[ -n "${active_tags_map[$repo_tag]:-}" ]]
}

# Get tags to delete for a repository
get_tags_to_delete() {
    local repo_name=$1
    local images=$2
    local -n delete_array=$3
    local -n active_count=$4

    local current_timestamp
    current_timestamp=$(date +%s)
    local thirty_days_seconds=$((30 * 24 * 60 * 60))
    local cutoff_timestamp=$((current_timestamp - thirty_days_seconds))

    local image_data
    image_data=$(echo "$images" | jq -r '.imageDetails[] |
        {
            digest: .imageDigest,
            tags: (.imageTags // []),
            pushedAt: .imagePushedAt
        } |
        @json')

    while IFS= read -r image_json; do
        if [ -z "$image_json" ]; then
            continue
        fi

        local image_digest
        image_digest=$(echo "$image_json" | jq -r '.digest')

        local tags
        tags=$(echo "$image_json" | jq -r '.tags[]?' 2>/dev/null || echo "")

        local pushed_at
        pushed_at=$(echo "$image_json" | jq -r '.pushedAt // ""')

        local is_active=false
        local is_recent=false

        # Check if the image is less than 30 days old
        if [ -n "$pushed_at" ] && [ "$pushed_at" != "null" ]; then
            local pushed_at_epoch
            # Using python for the date timestamp conversion
            pushed_at_epoch=$(python3 -c "from datetime import datetime; print(int(datetime.fromisoformat('$pushed_at'.replace('Z', '+00:00')).timestamp()))" 2>/dev/null || echo "0")

            if [ "$pushed_at_epoch" -gt "$cutoff_timestamp" ]; then
                is_recent=true
            fi
        fi

        # Check if the sha256 image tag is active
        if is_tag_active "$repo_name" "$image_digest"; then
            is_active=true
        fi

        # Also check if any normal tagged images are active
        if [ "$is_active" = false ] && [ -n "$tags" ]; then
            for tag in $tags; do
                if is_tag_active "$repo_name" "$tag"; then
                    is_active=true
                    break
                fi
            done
        fi

        # Keep image if it's active OR recent (less than 30 days old)
        if [ "$is_active" = true ] || [ "$is_recent" = true ]; then
            ((active_count++)) || true
        else
            delete_array+=("$image_digest")
        fi
    done <<< "$image_data"
}

# Delete images
delete_images() {
    local repo_name=$1
    shift
    local images_to_delete=("$@")

    for ((i=0; i<${#images_to_delete[@]}; i+=100)); do
        local batch=("${images_to_delete[@]:i:100}")

        if [ "$DRY_RUN" = true ]; then
            echo "[DRY RUN] Would delete ${#batch[@]} images from $repo_name:"
            for digest in "${batch[@]}"; do
                echo "  - $digest"
            done
        else

            local image_ids
            image_ids=$(printf '%s\n' "${batch[@]}" | jq -R -s -c 'split("\n") | map(select(length > 0)) | map({imageDigest: .})')

            local result
            result=$(aws ecr batch-delete-image \
                --repository-name "$repo_name" \
                --region "$REGION" \
                --image-ids "$image_ids" \
                --output json 2>&1) || {
                    echo "ERROR: Failed to delete images from $repo_name"
                    continue
                }

            local deleted
            deleted=$(echo "$result" | jq '.imageIds | length' 2>/dev/null || echo 0)
            local failed
            failed=$(echo "$result" | jq '.failures | length' 2>/dev/null || echo 0)

            echo "Deleted $deleted images from $repo_name ($failed failures)"

            if [ "$failed" -gt 0 ]; then
                echo "$result" | jq -r '.failures[] | "  WARNING: Failed to delete \(.imageId.imageDigest): \(.failureReason)"'
            fi
        fi
    done
}

# Clean up a repository
cleanup_repository() {
    local repo_name=$1

    local images
    images=$(aws ecr describe-images \
        --repository-name "$repo_name" \
        --region "$REGION" \
        --output json 2>/dev/null) || {
            echo "WARNING: Failed to describe images for $repo_name"
            return
        }

    local total_images
    total_images=$(echo "$images" | jq '.imageDetails | length')

    if [ "$total_images" -eq 0 ]; then
        return
    fi

    local active_count=0
    for repo_tag in "${!active_tags_map[@]}"; do
        if [[ $repo_tag == $repo_name:* ]]; then
            ((active_count++)) || true
        fi
    done

    local images_to_delete=()
    local active_images=0
    get_tags_to_delete "$repo_name" "$images" images_to_delete active_images

    # Store results for summary table
    repository_results+=("$repo_name|$total_images|$active_images|${#images_to_delete[@]}")

    # Store full image URLs for images to delete
    for digest in "${images_to_delete[@]}"; do
        images_to_delete_urls+=("$ECR_REGISTRY/$repo_name@$digest")
    done

    if [ ${#images_to_delete[@]} -gt 0 ] && [ "$DRY_RUN" = false ]; then
        delete_images "$repo_name" "${images_to_delete[@]}"
    fi
}

print_summary_table() {
    echo ""
    echo "========================================================================================================="
    printf "%-40s | %-15s | %-15s | %-15s\n" "Repository" "Total Images" "Active Images" "Images to Delete"
    echo "========================================================================================================="

    for result in "${repository_results[@]}"; do
        IFS='|' read -r repo total active delete <<< "$result"
        printf "%-40s | %-15s | %-15s | %-15s\n" "$repo" "$total" "$active" "$delete"
    done

    echo "========================================================================================================="
    echo ""

    if [ ${#images_to_delete_urls[@]} -gt 0 ]; then
        echo "Images to be deleted:"
        echo ""

        printf '%s\n' "${images_to_delete_urls[@]}" | sort | while read -r url; do
            echo "  $url"
        done
        echo ""
    fi
}

main() {
    echo "ECR Cleanup Starting"
    echo "Dry Run: $DRY_RUN"
    echo ""

    # Get ECR registry URL
    local account_id
    account_id=$(aws sts get-caller-identity --query Account --output text)
    ECR_REGISTRY="$account_id.dkr.ecr.$REGION.amazonaws.com"

    get_active_tags

    echo ""
    echo "Analyzing repositories..."

    repository_results=()
    images_to_delete_urls=()

    for repo in "${REPOSITORIES[@]}"; do
        cleanup_repository "$repo"
    done

    print_summary_table
}

main
