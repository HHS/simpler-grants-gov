name: Build and publish
run-name: Build and publish ${{ inputs.app_name }}:${{ inputs.ref }}

on:
  workflow_call:
    inputs:
      app_name:
        description: "name of application folder under infra directory"
        required: true
        type: string
      ref:
        description: The branch, tag or SHA to checkout. When checking out the repository that triggered a workflow, this defaults to the reference or SHA for that event. Otherwise, use branch or tag that triggered the workflow run.
        required: true
        type: string
      publish:
        description: Should the action publish the docker image to ECR after building (no for vuln scans, yes for other builds)
        required: false
        default: true
        type: boolean
    outputs:
      commit_hash:
        description: The SHA that was built
        value: ${{ jobs.get-commit-hash.outputs.commit_hash }}
  workflow_dispatch:
    inputs:
      app_name:
        description: "name of application folder under infra directory"
        required: true
        type: string
      ref:
        description: The branch, tag or SHA to checkout. When checking out the repository that triggered a workflow, this defaults to the reference or SHA for that event. Otherwise, use branch or tag that triggered the workflow run.
        required: true
        type: string
      publish:
        description: Should the action publish the docker image to ECR after building (no for vuln scans, yes for other builds)
        required: false
        default: true
        type: boolean

jobs:
  get-commit-hash:
    name: Get commit hash
    runs-on: ubuntu-22.04
    outputs:
      commit_hash: ${{ steps.get-commit-hash.outputs.commit_hash }}
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ inputs.ref }}
          fetch-depth: 1000
      - name: Get commit hash
        id: get-commit-hash
        run: |
          APP_COMMIT_HASH=$(git log --pretty=format:'%H' -n 1 ${{inputs.ref}} ${{ inputs.app_name}})
          COMMIT_HASH=$(git rev-parse ${{ inputs.ref }})
          echo "Commit hash: $COMMIT_HASH, App: $APP_COMMIT_HASH"
          echo "commit_hash=$APP_COMMIT_HASH" >> "$GITHUB_OUTPUT"
  build-and-publish:
    name: Build and publish
    runs-on: ubuntu-22.04
    needs: get-commit-hash
    concurrency: ${{ github.workflow }}-${{ needs.get-commit-hash.outputs.commit_hash }}

    permissions:
      contents: read
      id-token: write

    steps:
      - uses: actions/checkout@v5
        with:
          ref: ${{ inputs.ref }}
          fetch-depth: 1000

      - name: Set shared outputs
        id: shared-output
        run: |
          IMAGE_NAME=$(make APP_NAME=${{ inputs.app_name }} release-image-name)
          IMAGE_TAG=$(make APP_NAME=${{ inputs.app_name }} release-image-tag)
          echo "image=$IMAGE_NAME:$IMAGE_TAG" >> "$GITHUB_OUTPUT"
          echo "image=$IMAGE_NAME:$IMAGE_TAG"
          make APP_NAME=${{ inputs.app_name }} dump-env

      - name: Set up Terraform
        uses: ./.github/actions/setup-terraform

      - name: Configure AWS credentials
        uses: ./.github/actions/configure-aws-credentials
        with:
          app_name: ${{ inputs.app_name }}
          environment: shared

      - name: Check if image is already published
        id: check-image-published
        run: |
          is_image_published=$(./bin/is-image-published "${{ inputs.app_name }}" "${{ needs.get-commit-hash.outputs.commit_hash }}")
          echo "Is image published: $is_image_published"
          echo "is_image_published=$is_image_published" >> "$GITHUB_OUTPUT"

      - name: Set up Docker Buildx
        if: steps.check-image-published.outputs.is_image_published == 'false'
        uses: docker/setup-buildx-action@master

      - name: Cache Docker layers
        id: cache-buildx
        uses: actions/cache@v4
        with:
          path: /tmp/.buildx-cache
          key: ${{ inputs.app_name }}-buildx-${{ needs.get-commit-hash.outputs.commit_hash }}
          restore-keys: |
            ${{ inputs.app_name }}-buildx-

      - name: Ensure Buildx cache exists
        run: |
          mkdir -p /tmp/.buildx-cache

      - id: restore-frontend-package-cache
        if: steps.check-image-published.outputs.is_image_published == 'false' && inputs.app_name == 'frontend'
        name: Restore cached node_modules
        uses: actions/cache/restore@v4
        with:
          path: ${{ github.workspace }}/frontend/node_modules
          key: frontend-node_modules-${{ hashFiles('frontend/package*.json') }}
          fail-on-cache-miss: true

      - id: restore-build-cache
        if: steps.check-image-published.outputs.is_image_published == 'false' && inputs.app_name == 'frontend'
        name: Restore build cache
        uses: actions/cache/restore@v4
        with:
          path: |
            ${{ github.workspace }}/frontend/.next/standalone
            ${{ github.workspace }}/frontend/.next/static
          key: frontend-build-${{ github.sha }}
          fail-on-cache-miss: true

      - name: Build release container
        id: build-release-container
        if: steps.check-image-published.outputs.is_image_published == 'false' && steps.cache-buildx.outputs.cache-hit != 'true'
        run:
          make APP_NAME=${{ inputs.app_name }} IMAGE_TAG=${{needs.get-commit-hash.outputs.commit_hash }} release-build \
          OPTIONAL_BUILD_FLAGS=" --cache-from=type=local,src=/tmp/.buildx-cache --cache-to=type=local,dest=/tmp/.buildx-cache"
          echo "built=true" >> "$GITHUB_OUTPUT"

      - name: Save Docker image
        if: steps.cache-buildx.outputs.cache-hit != 'true'
        run: |
          docker save ${{ steps.shared-output.outputs.image }} > /tmp/docker-image.tar

      - name: Cache Docker image
        if: steps.cache-buildx.outputs.cache-hit != 'true'
        uses: actions/cache/save@v4
        with:
          path: /tmp/docker-image.tar
          key: ${{ inputs.app_name }}-docker-img-${{ needs.get-commit-hash.outputs.commit_hash }}

      - name: Restore cached Docker image
        if: steps.build-release-container.outputs.built != 'true'
        uses: actions/cache/restore@v4
        with:
          path: /tmp/docker-image.tar
          key: ${{ inputs.app_name }}-docker-img-${{ needs.get-commit-hash.outputs.commit_hash }}
          restore-keys: |
            ${{ inputs.app_name }}-docker-img-

      - name: Load cached Docker image
        if: steps.build-release-container.outputs.built != 'true'
        run: |
          docker load < /tmp/docker-image.tar

      - name: Publish release
        if: steps.check-image-published.outputs.is_image_published == 'false' && inputs.publish == true
        run: make APP_NAME=${{ inputs.app_name }} IMAGE_TAG=${{needs.get-commit-hash.outputs.commit_hash }} release-publish
